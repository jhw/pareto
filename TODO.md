### short

- allow parameter fields to be lower case
- pass kwargs to parameters

- ref filtering to use set()

- new actions dashboard component

### medium

- apigw logging
- layers-as-components

- merge website back into bucket

- investigate moving more script stuff into template

- refactor api resource vs endpoint nomenclature
- api request validation

- consider class- based implementation ?

- userpool component
- api authorizer
- userpool ref validation
- auth testing scripts

- generic reference mechanism

- action to have permission to call another action

- s3 multiple action support
- cloudfront + https + route 53
- change password routine
- template factory
- scaffold generator
- targets

### v1.1

- auth
  - self sign- up
  - forgot password
  - federated login
  - unauthenticated access

- cloudwatch alerts
- eventbridge
- ci pipeline
- github actions
- lambda xray
- step functions
- fargate
- appsync/graphql
- topology charts

### thoughts

- api endpoint to have multiple methods ?
  - no; for now is enough to have a specified endpoint and a cors endpoint
- test pushing nested yaml templates to s3 ?
  - simply not worth it, JSON easier
- @singleton decorator ?
  - no just munge the resource names to be the same 
- apigw2 ?
  - probably not worth it if the original apigw works fine
- refactor layers as singletons ?
  - no because may have different versions of the same package which means they have need to be defined on a per function basis  
- check output refs ?
  - no [notes]
- move nested stack param munging into stack component ?
  - no because it involves resolving template key to stack name so belongs in env
- replace api gateway stage name (currently == stage name) with action name ?
  - possibly seems logical but then this doesn't seem to be the recommended API gateway pattern
- remove template naming facility ?
  - no because dashes need names
- dsl json schema ?
  - probably not worth it
- investigate why funcarn defined twice in bucket but only once in website
  - because website inherits BucketPermission
- should actions have a dedicated suffix to make things easier ? harder ?
  - no
- all triggers to have option of using parameter- based action arns ?
  - not if string based arns work fine 
- cloudwatch alerts in v1.1 ?
  - no because probably sufficient to connect dead letter queue to lambda which then pushes to slack or discord webhook
  - alerts are really for when you want to look at aggregate performance of cloudwatch logs rather than one particular individual error
- push index.json as part of deployment ?
  - no; remember amplify has separate push, publish actions
- specific iam permissions for layer build ?
  - simply not worth it
- support for layer arns ?
  - not worth it; build_layer.py works fine for numpy/scipy
- simplify layer key constructors ?
- add awscore to pip imports ?
  - think is fine as it is ?
- export trigger, function arns ?
  - only if you plan to tie down policy document Resource field, which is currently a wildcard
- multiple stacks per type ?
  - don't think it's worth it at this stage
- avoid having to specify empty action ?
  - can't think of decent way around it
- see if LambdaMapping can be abstracted
  - no they are fairly unique
- see if permissions generation code can be harmonised like iam roles
  - no; quite specific
- harmonise permission resource names (LambdaPermission, ApiGwPermission) ?
  - single Permission to which u pass source ?
  - probably not worth it
- convert to class based representation ?
  - doesn't seem worth it right now
- change package refs to pkg ?
  - not worth it
- clean up codebuild project every time ?
  - no because then you probably want to clean the role also which can be successfully reused
  - is probably better to have empty_artifacts.py do a global clean
- avoid resetting codebuild project every time ?
  - problem is buildspec is part of source arg passed to create_project
- build_layer.py to implement all time.sleep(wait) calls as decorators ?
  - structure doesn't really warrant it
- singularise stack names ?
  - no is too complex as means you also have to singularise references
  - if you really want to singularise stuff, singularise the keys in the dsl
- pass staging details as params ?
  - no; see notes
- pluralise dashboard stack / template name ?
  - no is fine singular
- replace role wait with waiter ?
  - doesn't seem to work
- pip install from git ?
  - probably not required at this stage
- extend global names (staging/bucket ?)
  - no because you already include \"staging\" key as part of push_lambdas.py
- add support for optional args ?
  - only required for version, and think this is better specified as suffix
- add back separate build stage so you can push multiple packages to build ?
  - no u don't need this as can use wildcards
- convert setenv.sh tp python and move into scripts ?
  - no because you don't want it to be part of pareto
- rename globals.bucket as staging.bucket ?
  - no because it's just an extra dict you've got to copy to each component
- rename globals.app as globals.name ?
  - no because conflicts with resource.name 
- consider how to avoid `ref("%s-xxx" % kwargs["name"])`
  - use reference checker
- managed IAM policies ?
  - not clear u need them
- sqs fifo ?
  - not clear u need it
- resource decorator to use blank props as default
  - there's no nice easy way to add a default second arg I don't think
  - simpler to make it explicit
- deploy_stack.py to check for existence of names -stage suffix
  - is probably overkill if you have reduced use of resource_name to bare minimum and are also using random_name in many unimportant places
- don't include empty props ?
  - fails if u delete them
- only add bucket name if website ?
  - no it could be something u want a dashboard for
- rename deploy_stack.py config to avoid confusion with Config ?
  - no I prefer using config to dsl
- remove master outputs / list_outputs.py to iterate over all nested stacks
  - no because add_master() is quite elegant and it doesn't take much work to do this 
- move type filters into __init__.py ?
  - no because filters are different
- custom template type for dashboard ?
  - seems like overkill 
- aggregate IAM roles ?
  - doesn't seem worth it when unlikely to be template size constraint
- consider converting Template to extend object not dict ?
  - no point
- investigate template usage of lists of tuples (dicts ?)
  - no is fine
- refactor env.py so each function returns a template/templates ?
  - no is fine
- multiple sqs actions ?
  - i think leave it as single action for time being for simplicity
- add outputs support to fn::getatt ? option to bypass logical_id ?
  - think it's simpler just to have special function in master template
- refactor env to use Master function and don't have it attach directly ?
- preprocessor unit tests ?
  - probably not worth it at this stage, assuming it all compiles
- iam role pool to reduce template size ?
  - not going to reduce template size meaningfully
  - also feels like an over- optimisation
- don't put blank subs {} ?
  - doesn't work - needs blank
- preprocessor circularity detection ?
  - trig!=target unless s3 bucket, in which case paths can't be the same
  - just too meta for now
- separate functions for arn creators if they can't work on a single line
- eliminate `:::` in S3 bucket policy ?
  - no, seems to be standard case
  - https://docs.aws.amazon.com/AmazonS3/latest/dev/example-bucket-policies.html
- use ${AWS::Region} ?
  - no; dash will never support it as supposed to be multi- region
- convert underscored table attribute names to hashes ?
  - no; you don't do this for any other names so why bother with table ?
- find all tests rather than just index.py ?
  - conventions should be that all tests are in index.py
- remove managed policy support ?
  - no might be useful
- remove `-dashboard-` from dash name ?
  - too much hassle to allow dash to work without a name
- scripts to ping lambda, check logs ?
  - not really required as this is about deployment not runtime
  
### done

- move json/yaml template representation into template
- move reference checking into dash where can check self
- re- introduce template update helpers
- compare template sizes with start of day
- add back master
- add back ref checking
- missing components
- revert Template to dict
- yaml representer output problem
- move grid_layout to chart root
- retire dash temporarily
- comvert template to be list of dicts
- ensure all template updators convert lists of tuples to dicts
- comment out/remove all dash related stuff
- move template metrics into template
- remove element class
- separate preprocessor
- synth_dashboard
- rename finalise as synth_master
- new decorator to append
- test cors
- cors options method
- rename -api as -root
- check action refs
- check depends
- check resource, method, permission, output references
- configure single API with multiple resources, each with defined methods
- comment out options method
- add resource
- deploy / test
- separate apis template
- compare/contrast options methods (vs amplify_auth_demo)
- test cors with curl
- ensure all header- like methods which use string values make use of single quotes
- incorporate rewrite_single_strings so json consistent with yaml
- add notes re single string formatting
- json single quote renderer
- deployment depends
- models is dual nested
- models headers
- apigw options method
- validate resource return type
- all resources to return three args
- remove fill- in code in @resource
- new decorator to fill in blank args
- replace checking for `actions` in `components` with decorators
- deploy and test dashboard
- dashboard naming
- pass temp name to template
- add back old self- contained dash
- remove new dashboards stuff 
- add back dashboard class
- use yaml.safe_load
- insert dynamodb, sqs lookback permissions
- new preprocessor validation step
- validate action refs
- validate uniqueness
- use logical_id for stack name so `non-actions` will resolve to `NonActions`
- rename components as actions
- check "actions" before iterating over config["components"]["actions"]
- investigate adding region and account id to hardcoded event sources
- remove dashboard and named templates
- merge init_master() into Env class
- init_master into env as finalise
- rename templates as env
- move init_templates into env
- templates for each group need to be pre- created / appended
  - as they are currently overriding one another
- template mapping function
- test everything under triggers
- avoid passing rendered template to master
- render at end
- templates class
- add dynamodb, sqs lookback permissions to config
- remove event_mapping_permissions
- check wildcard permissions handling
- deploy/test
- ping apis
- add back timers
- add back buckets, websites
- fix RestApiId
- fix rest api type
- stack params are badly defined
  - first arg is stack ref
  - second is string containing outputs
  - re- test check refs
- add nested parameters
- how come there is no 
- look for example of nested parameters
- filter outputs from all templates
- simplify api gateway arn construction
- rename `ApiGw` as simply `Api`
  - rename `ApiApi` as `ApiRestApi` or `ApiRoot`
- add back ref checking
- simplify website lambda config
- api still using internal function arns
- timer has bad internal refs
- remove api-gw suffix
- action arn outputs are mis- specified
- remove api arn exports
- remove -action suffix
- extend action names in dsl
- fix -action-arn 
- parameter to be conditional and created of kwargs["action"] not kwargs["name"]
- replace trigger action arns with parameter refs
- check parameter support
- test generation
- move actions as first class citizen in dsl and add trigger refs to actions
- remove env addition of actions
- comment out dash, ref checking
- remove trigger arn outputs
- api arns
- bucket/website arns
- all triggers to export arn
- all actions to export function arn
- add back dashboards
- env to synth actions where they exist
- refactor synth_action so creates a template
- restrict triggers to adding non- action related components
- remove dashboard stuff
- reduce default lambda size
- build_layer.py to replace jinja2 with string.format
- could synth_action be better implemented?
- add layers to apis
- test pinging apis with layer imports
- test deployment
- action to include layer references
- separate permission, mapping args in synth action
- pass permission ref to synth_action
- check an action can't have two versions of the same package
- layer runtime
- create layer component
- iterate through layers
- website will fail on bucket action permission
- synth_action function
- simplify commits assignment
- add layer staging to deploy_stack.py
- new method to create layer key given name, version args
- add 'Action' to chart titles
- check specifying lambda commit still works
- move deploy_stack assign_commits to LamdaCommits ?
  - no is fine as it is
- simplify template creation in env
  - don't think u need all that grouping stuff
- create name from app, dashname and stagename
- pass name arg to template and dash
- dash to use name as dashboard name
- remove /dev
- test deployment
- dashboard grid layout
- check rendering of dash
- render dash as resource tuple
- comment out printing and append dash as resource
- import action charts into action
- anything that creates an action to create action charts
- comment out dash rendering
- new charts.actions chart renderers
- add parameters, resources, outputs classes to template
- add dashboard class with merge, render classes
- ensure that template merging, rendering calls dash merging, rendering
- add charts with README
- remove all dash code and add to /dev
- move env and template into root
- add pip dependencies
  - https://python-packaging.readthedocs.io/en/latest/dependencies.html
  - https://stackoverflow.com/questions/32688688/how-to-write-setup-py-to-include-a-git-repo-as-a-dependency/32689886
- move project tests into separate tests directory
- change lambda staging so leaf values are objects not strings
- add `lambda` to staging
- argsparse isn't checking for unknowing files
- test changing globals.src
- push_lambdas to use sys.path.append
- test what happens to following scripts if you restrict PYTHONPATH to .
  - test.py
  - push_lambdas.py
  - deploy_stack.py
- sqs event mapping permissions are insufficient 
- add wildcard permissions check
- add specific translate, polly permissions
- permissions aggregator to use sorted(list(set()))
- specific lambda logs permissions

```
If you created your log group manually, you'll only need to give the Lambda two permissions: logs:createLogStream and the logs:PutLogEvents permission. If you didn't create the log group manually, you'll also need to add the logs:CreateLogGroup permission
```

- abstract template
- remove wildcard check from event_mapping_permissions
- abstract event_mapping_permissions
- restrict dead letter queue permissions to sqs:SendMessage
- add dedicated permissions for sqs event mapping
- timer circular dependency
- include region in hardcoded event sources
  - is region included anywhere else ?
- add sample timer to hello.yaml
- note regarding specific sqs permissions
- replace s3 permission with something custom
- handle empty permissions
- reduce amount of permissions
- add default logs permissions
- add secret module
- test secret example
- separate secrets stack
- check output suffixes
- remove s3 path support
- merge ActionRole and IamRole
- separate out and rename website components
- separate website module again
- website_config not being used
- harmonise use of funcname, funcarn
- check use of decorators in table/queue/timer LambdaPermissions
  - why doesn't bucket use the same ?
- unpack components
- rename function as action
- remove preprocessor add_types.py
  - only required by deploy_stack.py but should be able to lookup from groupname
- remove preprocessor or integrate it elsewhere
- remove parameter import/export at master level
- lambda permission logical names are messed up
- s3 notification bindings are missing
- permissions are missing from roles
- refactor filter_functions
  - how is this going to work if u can't infer functions from components any more ?
- check arn bindings of all actions
- investigate why lambda permission needs a second action arg
- bucket/website to add multiple actions
  - replace imported arn parameter with local arn ref (see api)
- table, timer, queue to add single action
  - replace imported arn parameter with local arn ref (see api)
- convert api to work with method, permissions nested under actions key
- add permissions to all triggers in config
- remove actions config, component
- apigw resources not being created
- replace iam/permissions with simply permissions
- move function stuff into root
- simplyify action and api to use function
- combine bucket and website into single module
- replace lookback permissions with custom permissions
- see if iam stuff can be removed from preprocessor
- remove target stuff
- remap_types to add function parameter
  - rationalise handling of function detection
- remove `stack` suffix from stacks name
  - requires support for blank suffix
- pluralise dashboards name
- allow method to be top level api parameter
- dashboards is empty
- simplify remap function so just adds types
  - should apply to all components
- apis and actions need type variables
- replace function with separate action, api components
  - remove function type remapping
- replace bucket with separate bucket, website components
- filter_triggers function
- replace trigger group with nested template for each of queue/table/bucket etc
- ensure iterate over dsl component keys rather than hardcoded list of keys
- rename hello/lambda as demo/demo
  - causes push_lambdas.py to fail
  - no it doesn't, u have to change classpath
- remove types from apis, actions
  - causes preprocessor to fail
- dsl triggers/targets shouldn't require types
  - remove types from dsl key, if names are unique ?
- LayerPackages.exists w/ test
- rename add_staging as add_lambda_staging
- test.py to blank AWS profile
- s3 mock test for LayerPackages
- new LayerPackages class
- s3 mock test for LambdaCommits
- test for LayerPackage __str__
- LayerPackage __str__ function to re- render s3 key
- create_cli should really take config so it can include app
- refactor LambdaCommit.parse as LambdaCommit.create_s3
- refactor LayerPackage parse_xxx as create_xxx
- include app in LayerPackage.parse_s3
- new LayerPackage.parse_s3
- unit test for LayerPackage.parse_s3
- change LayerPackage.parse to parse_cli
- change LambdaCommits to parse keys on initialisation
- lambda root dir to be specified as part of config
- rename lambda key as lambda commit
- codebuild to terminate on stage failure
  - https://stackoverflow.com/questions/46584324/code-build-continues-after-build-fails
- single test.py script
- LayerPackage unit test
- single buildspec
- capture and iterate over not authorized error

```
ERROR - An error occurred (InvalidInputException) when calling the CreateProject operation: CodeBuild is not authorized to perform: sts:AssumeRole on arn:aws:iam::119552584133:role/pareto-demo-admin-role
```

- new layer package
- move layer code locally again
- change layer deployable name to include slash
- dump_env to iterate over keys and dump separate stacks
- add slash to tmp template asset
- simplify lambda key filename with slash between name and ts/hexsha
- move lambda helpers to lambda staging
- check deployment
- check deploy_stack.py
- push_lambdas.py
- clean_artifacts.py to remove codebuild admin role
- clean_artifacts.py to remove codebuild projects
- clean up methods used by scripts/__init__.py
- scripts/helpers
- add functions to xxx_artifacts.py
- try custom policy with codebuild, s3 permissions
- re- try waiter focused on policy
- deploy_stack.py dummy run
- lambda, layer runtimes to work from same config arg
- script to create and delete sample policy w/ adminstrator access
  - https://stackoverflow.com/questions/44121532/how-to-create-aws-iam-role-attaching-managed-policy-only-using-boto3
- replace config["role"] with dynamically managed policy
- script to search lambda logs
- inspect codebuild logs
- status poller / waiter
- add decorator to delete project if already exists
- add versioning option to package
- test not overriding artifact name
- test removing environment variables
- add codebuild role, runtime to globals
- move lamdba keys into scripts/__init__.py
- remove app.props
- add config["build"]
- insert package name from command line
- test with multi- package package [pymorphy]
- use templates for buildspec runtime insertion
- upgrade pip
- use package name as layer name
- layer generation script
- class based structure to filter lambda deployables by latest, commits etc
- lambda path class to help scripts
- search_replace.py
- argsparse
- add secrets to resources
- add sample secret to config
- master to iterate over secrets
- add secret component to master stack
- add support for complex/JSON secrets
- add more specific error messages on staging failure
- commit lookup seems to be failing
- separate filter_keys from add_staging
- add option to pass thru commit
- add method to group lambda keys by commit as well as latest
- fetch_s3 to use paginator
- change add_staging so s3 files are fetched first and then grouped
- add_staging to use fetch_s3
- scripts to handle stack query errors during deletion

```
An error occurred (ValidationError) when calling the DescribeStackEvents operation: Stack [pareto-demo-dev-DashboardStack-19NKH4R342WC7] does not exist
```

- check optional lambda memory, timeout params
- allow lambda retries to be specified in config
- check if lambda exists before pushing
- adapt deploy stack to handle new file format
- use commit timestamp rather than generated timestamp
- add git commit as additional S3 file salt
  - as timestamp suffix so can order by time
- get new files added to repo
- demo routine to find latest lambda git commit
- list lambdas as roots
- store with root rather than diff
- exit when complete
- add max iterations or cutoff
- log lambdas being used
- deploy stack to list S3 deployments and use latest
- separate lambda push from deploy stack
- pip install python git
- script to list artifacts
- script to clean artifacts
- validate staging bucket exists
- lookup region from env
- replace app.props with globals section in dsl config
- reference checker
- add decorator to fill in blank resource props
- use template variables for stage name
- ping api gw endpoints
- check api gateway handler code in api actions
- should stage name really be part of API GW URL ?
- consider reverting resource_id/name to take kwargs not **kwargs
- remove dict handling in list_outputs.py
- remove export of outputs
- outputs script to iterate over all templates
- rename resource_id as resource_name
- add back rest api name
- randomise policy name
- see if you still need resource suffix support
- try removing rest API name
- replace local refs to function names with arns
  - as they use logical id rather than (more complex) resource name
  - except in the case of s3 source arn
- then had better redeploy and make sure the damn thing still actually deploys okay, with the full hello.yaml input
- test selectively removing names
- test replacing resource_id based references with arns or similar
- adapt resource_id to take optional suffix
- convert resource id to accept **kwargs
- layer name
- new layer component
- nest app/stage/region/bucket in config.globals
- remove support for managed iam policies
- IamRole to be part of function component
- adapt inspection scripts for multiple stacks
- dashboard needs to return template
- harmonise s3 lambda, template paths
  - remember lambda path should not include stage name
- simplify master stack params, output creation

```
Template error: instance of Fn::GetAtt references undefined resource HelloAction2
```

- *** s3 event notifications are still using direct function arn refs rather than refs to params ***

- json templates not yaml :-)
- access denied error
  - do s3 templates exist ?
- weird that doesn't include triggers stack
- remove empty templates ?
- bad cloudformation ref
- master outputs must be nested under value
- outputs ref to be part of attr not stack name
- add back stack dumping
- add back deployment script
- fix back refs to Config
- template push
- add back metrics
- add metrics alerts
- add back lambda push
- add back lambda testing
- simplify dashboard marshalling
- dashboard to filter for the existence of functions
- dashboard stack
- refactor creation of api/action/trigger stacks as per master
  - avoid popping components
- pass config, templates to init_template
- simplify env.py creation
  - avoid popping components from config
- add local copies of synth_template and rename as init_template
- see if you can remove dict from render method
- add render method to template
- stack to return template
- remove trim method from template
- synth_template should use Template class
- move synth_template into env
- add Template class
- remove trim_template
- pop outputs so internal ones are not exposed publically
- include aggregated outputs in master stack
- add per- stack parameters
- filter outputs from each component group {name: stack}
- trim() decorator to remove empty params/resources/outputs
- stack for each component group
- stack url
- pass parameters to stack
- stack needs its own component
- when creating environment need to use synth_template(config) etc
- stack needs to become environment
- convert remaining trigger arns to parameters and refs
- convert local ARN lookups to parameter refs
- sample parameter
- pass components to template
- generate and save mutiple stacks
- add dashboard stack
- add master stack
- stack type filters
- rename stack as template
- new stack file which creates multiple templates
- comment out deployment
- remove metrics
- remove dashboard
- ensure all yaml dumping done without refs
- raw stack is missing iam permissions
  - but works when u run preprocessor from the command line
- dump raw, cooked templates
- iam/permissions is nested incorrectly
- preprocessor demo.yaml sample
- integrate preprocessor via decorator
- force depends to be a list
- remove iam compaction
  - check iam uses set
- lambda retry behaviour
  - https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-eventinvokeconfig.html
- export important ARNs/refs
- preprocessor to include sqs by default for dlq
- dead letter queues
- rename stack.yaml as demo.yaml
- note and remove specific iam support

```
2020-06-27 13:32:16.383000+00:00		HelloTableHelloGetMapping		AWS::Lambda::EventSourceMapping		Cannot access stream arn:aws:dynamodb:eu-west-1:119552584133:table/pareto-demo-hello-table-dev/stream/2020-06-27T13:31:43.497. Please ensure the role can perform the GetRecords, GetShardIterator, DescribeStream, and ListStreams Actions on your stream in IAM. (Service: AWSLambda; Status Code: 400; Error Code: InvalidParameterValueException; Request ID: 08979523-6e69-425a-88bf-13772486119b)
```

```
2020-06-27 13:35:48.379000+00:00		HelloQueueHelloGetMapping		AWS::Lambda::EventSourceMapping		The provided execution role does not have permissions to call ReceiveMessage on SQS (Service: AWSLambda; Status Code: 400; Error Code: InvalidParameterValueException; Request ID: 9e0c49ef-e60f-45de-a789-dc6ce39ff196)
```

- capture precise ddb, sqs actions required for lookback
- aws scripts to support missing attributes
- add S3 AccountId
- better decorator handling in logical id formatting of depends
- depends should be automatically converted to logical id
- refactor global_name as resource_id
- new logical_id wrapper for hungarorise
- https://aws.amazon.com/premiumsupport/knowledge-center/unable-validate-circular-dependency-cloudformation/
- deployment fails if no outputs (eg bucket (no website) and function)
- comment out bucket sourcearn
- check all scripts work on malformed stacks
  - delete_stack fails on missing S3 bucket
  - delete_stack doesn't appear to log IAM role deletion
- eliminate ${AWS::Partition}
- use `fn::sub` in bucket policy creation
- replace :aws: with :${AWS::Partition}
- harmonise `Allow` vs `allow`
- remove `Sid`
- https://docs.aws.amazon.com/apigateway/latest/developerguide/arn-format-reference.html
- https://docs.aws.amazon.com/lambda/latest/dg/services-apigateway.html

```
$ aws lambda add-permission --function-name my-function \
--statement-id apigateway-get --action lambda:InvokeFunction \
--principal apigateway.amazonaws.com \
--source-arn "arn:aws:execute-api:us-east-2:123456789012:mnh1xmpli7/default/GET/"
```

- the number is the account number, so can maybe be ignored
- test dashboard yaml
  - doesn't work
- s3, cloudwatch event permission source
- comment out temp code in stack.yaml
- re- test stack.yaml deployment
- expose lambda options to dsl
  - audio generator will require concurrency
- add unique name testing
- embed validation in wrapper method
- abstract iam class
- abstract iam methods used by action
- allow api to add dest permissions
- allow preprocessor target to be optional
- change wildcard name to expand
- only add wildcard if no colon in name
- add render method to iam to convert to list
- add flatten method to iam which removes specifics if wildcard exists
- move attach decorator
- move wildcard decorator
- default logs permission
- move wildcard function to iam class
- avoid duplicating permissions
- add iam wildcard
- arg parameters
  - s3:ObjectCreated:*
  - NEW_IMAGE (ddb)
- test optional args
- sqs batch size
- trigger, target permissions
- batch handling
- add target info to slow russian
- validate and clean up targets
- bucket website
- eval() test
- replace func type with separate api, action types
  - nest/hide api method field
- refactor preprocessor notes
- don't pop binding so u don't have to pass it
- rename self as trigger
- rename func as action
- rename target as action in main pareto body
- rename nonfunc as trigger
- rename src ac trigger
- refactor target references
  - should be popped from nonfuncmap
  - if necessary should be augmented by src/dest args [path]
  - remove need to sent 3rd arg to `add_xxx_target`
  - this is linked to the problem of queue batch not appearing at the right nesting level
- nest `target` with `name`, `batch`
- replace event source `function` with `target`
- add function permissions based on target (s3, ddb, queue)
- pass thru custom permissions
- check existing permissions before adding
- initialise permissions
- table schema
- queue batch
- functions with name `audio`, `content` look incorrect
- aggregate type/name keys
- validate uniqueness
- validate sources
- allocate sources to components and render
- ddb, sqs permissions
- bucket website support
- slow russian stack.yaml
- remove ddb/sqs permissions, redeploy
- list_failures.py
- add logger to stack deletion
- all scripts to capture client error
- delete_stack.py
  - empty buckets
  - detach IAM policies
  - capture waiter error
- change all scripts to use __init__.py
- move deploy code into scripts/__init__.py
- describe_outputs.py
- describe_stacks.py
- describe_events.py
- describe_resources.py
- deployment logger
- capture waiter error
- limit calculations
- separate get, post lambdas
- common helpers
  - filtering of functions from components
  - replacement of "-" with "_" in function name
- move scripts to pareto/scripts
- charts/functions/README
- toggle google before running tests
- run tests
- sample test file
- push_lambda to iterate over directory contents
- replace s3 bucket/key parameters with hardcoded values
- replace lambdakeys with config augmented by s3 bucket, key
- dump stack
- abstract timestamp
- push_lambda to check directory exists
- generate lambda keys by iterating over functions
- synth stack internally
- make Config static and avoid passing it round
- lambda key to be full s3key
- pass a dict of lambda keys, with function name
- stack create vs update
  - call describe stacks and see if it exists
- s3 upload failing
  - deploy.sh bytes => local 488 / remote 488
  - deploy.py bytes => local 436 / remote 360
- deploy stack and wait
- separate zfname from zipping
- python lambda deployment
- queue event mapping
- table event mapping
- s3 notifications
- table indexes
- table

```
 2020-06-13T05:11:13.573Z|  Table                   |  AWS::DynamoDB::Table        |  CREATE_FAILED                                |  One or more parameter values were invalid: Some AttributeDefinitions are not used. AttributeDefinitions: [my-string, my-int, my-hash], keys used: [my-hash, my-string] (Service: AmazonDynamoDBv2; Status Code: 400; Error Code: ValidationException; Request ID: VB2Q7GALG1S0RNLD0LPL6E6KHFVV4KQNSO5AEMVJF66Q9ASUAAJG)   |
```

- timer
- queue
- refactor DependsOn handling
  - avoid `len(props) > 2`
- add api gateway output to sample lambda
- test api gateway
- bad gateway rest api ref
- fix bad ref to Deployment
- api gateway DependsOn
  - needs to be returned as an (optional) third arg alongside Type, Properties
- move templates, lambda to tmp
- dash needs with and height parameters
- check dashboard
- role policy doc error
- deploy
- deploy script to push lambda
- deploy script to pass parameters
- configure function in demo.yaml
- index.py
- website
- test bucket deployments
- add stage name to all sh scripts
- remove blank outputs, parameters
- only add dashboard if not blank
- synth_stack.py to read config
- script to deploy stack
- stack.yaml
- script to generate stack
- setenv.sh
- pip packaging
