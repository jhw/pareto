### short [dashboard-refs]

- complete deploy_stack.py
- test

- refactor build_layer.py so not dependant on globals

- refactor references to globals in scripts

- test use of direct inline refs (`${AppName}` not `${app_name}`)

- add back template/dashboard name

- single layer

### pending

- API GW v1 vs v2
  - https://theburningmonk.slack.com/archives/GPM681W2K/p1598037249026700

- why is authorizer name- required ?
  - https://console.aws.amazon.com/support/home#/case/?displayId=7278988241&language=en

### medium

- script to dump outputs for UI
- ensure LambdaKey is only converted to str() at last minute
- abstract apigw decorator into demo root
- delete stack failed to clean s3 bucket
- apigw extended logging
- script to clean log groups
- group iam permissions according to service
- iam deployment user

- targets
- cloudfront
- route 53
- google sheets upload
- cloudwatch alerts

- apigw2 [stage auto deploy]

- pinpoint
  - https://console.aws.amazon.com/support/home#/case/?displayId=7278998251&language=en

- amplify change password
- amplify self sign- up
- amplify forgot password

- stripe
- webflow

### v1.1

- amplify federated login
- amplify unauthenticated access

- chrome extension
- eventbridge
- ci pipeline
- github actions
- lambda xray
- step functions
- fargate/ec2
- appsync/graphql
- topology charts

### thoughts

- remove validate_bucket ?
  - no; layer and lambda push still rely on it
- consider merging staging code back into scripts ?
  - err no
- consider removing staging tests ?
  - err no
- enable apigw logs
  - don't see the point if you're not customising apigw highly
- pip inclusion of non- python files ?
  - not an issue for now  
- force permissions to be required so u don't forget ?
  - think this is overkill
- scaffold generator ?
  - not convinced
- lambda version -> redeploy without s3 key change ?
  - absolutely no evidence this would work
  - and also u wouldn't want to give up existing lambda names anyway
- HTTP POST x-form-www-urlencoded handler
  - too complex as doesn't seem to fit inside the lambda proxy / model integration
  - just use JSON instead
- preprocess templates prior to staging ?
  - not possible; just ignore staging field
- script to login user ?
  - not really required here 
- test() script to ping all apis and buckets ?
  - no because u have this already for api access
- __main__ blocks for all components like userpool ?
  - not worth it
- check for capitalisation of 2nd arg to fn_getatt  ?
  - not worth it
- allow params validation for GET only ?
  - no is useful for POST too probably
- option for internal or external arn refs ?
  - not sure is worth it
- pop_dashboards() ?
  - over optimisation
- abstract push_lambdas.py code into class
  - hard to see how this can be a class
- genericise preprocessor reference checking ?
  - not sure it's worth it
- consider if lambda/layout staging stuff could be moved into class
  - struggling to see how that would work
- consider if python-git stuff could be moved into class ?
  - no because is very one- off stuff
- could CF.validate_template() be useful ?
  - no; just checks syntax
- refactor api resource vs endpoint nomenclature ?
  - no point
- convert capitalized variables to lower case ?
  - over- optimisation :/
- pass kwargs to parameters ?
  - don't see the point
- allow parameter fields to be lower case ?
  - don't see the point
- consider class- based implementation ?
  - really don't see the pointx
- trigger creation failed :-/
  - compare generated templates with master branch ?
  - feels like isolated incident as worked the next time
- api endpoint to have multiple methods ?
  - no; for now is enough to have a specified endpoint and a cors endpoint
- test pushing nested yaml templates to s3 ?
  - simply not worth it, JSON easier
- @singleton decorator ?
  - no just munge the resource names to be the same 
- apigw2 ?
  - probably not worth it if the original apigw works fine
- refactor layers as singletons ?
  - no because may have different versions of the same package which means they have need to be defined on a per function basis  
- check output refs ?
  - no [notes]
- move nested stack param munging into stack component ?
  - no because it involves resolving template key to stack name so belongs in env
- replace api gateway stage name (currently == stage name) with action name ?
  - possibly seems logical but then this doesn't seem to be the recommended API gateway pattern
- remove template naming facility ?
  - no because dashes need names
- dsl json schema ?
  - probably not worth it
- investigate why funcarn defined twice in bucket but only once in website
  - because website inherits BucketPermission
- should actions have a dedicated suffix to make things easier ? harder ?
  - no
- all triggers to have option of using parameter- based action arns ?
  - not if string based arns work fine 
- cloudwatch alerts in v1.1 ?
  - no because probably sufficient to connect dead letter queue to lambda which then pushes to slack or discord webhook
  - alerts are really for when you want to look at aggregate performance of cloudwatch logs rather than one particular individual error
- push index.json as part of deployment ?
  - no; remember amplify has separate push, publish actions
- specific iam permissions for layer build ?
  - simply not worth it
- support for layer arns ?
  - not worth it; build_layer.py works fine for numpy/scipy
- simplify layer key constructors ?
- add awscore to pip imports ?
  - think is fine as it is ?
- export trigger, function arns ?
  - only if you plan to tie down policy document Resource field, which is currently a wildcard
- multiple stacks per type ?
  - don't think it's worth it at this stage
- avoid having to specify empty action ?
  - can't think of decent way around it
- see if LambdaMapping can be abstracted
  - no they are fairly unique
- see if permissions generation code can be harmonised like iam roles
  - no; quite specific
- harmonise permission resource names (LambdaPermission, ApiGwPermission) ?
  - single Permission to which u pass source ?
  - probably not worth it
- convert to class based representation ?
  - doesn't seem worth it right now
- change package refs to pkg ?
  - not worth it
- clean up codebuild project every time ?
  - no because then you probably want to clean the role also which can be successfully reused
  - is probably better to have empty_artifacts.py do a global clean
- avoid resetting codebuild project every time ?
  - problem is buildspec is part of source arg passed to create_project
- build_layer.py to implement all time.sleep(wait) calls as decorators ?
  - structure doesn't really warrant it
- singularise stack names ?
  - no is too complex as means you also have to singularise references
  - if you really want to singularise stuff, singularise the keys in the dsl
- pass staging details as params ?
  - no; see notes
- pluralise dashboard stack / template name ?
  - no is fine singular
- replace role wait with waiter ?
  - doesn't seem to work
- pip install from git ?
  - probably not required at this stage
- extend global names (staging/bucket ?)
  - no because you already include \"staging\" key as part of push_lambdas.py
- add support for optional args ?
  - only required for version, and think this is better specified as suffix
- add back separate build stage so you can push multiple packages to build ?
  - no u don't need this as can use wildcards
- convert setenv.sh tp python and move into scripts ?
  - no because you don't want it to be part of pareto
- rename globals.bucket as staging.bucket ?
  - no because it's just an extra dict you've got to copy to each component
- rename globals.app as globals.name ?
  - no because conflicts with resource.name 
- consider how to avoid `ref("%s-xxx" % kwargs["name"])`
  - use reference checker
- managed IAM policies ?
  - not clear u need them
- sqs fifo ?
  - not clear u need it
- resource decorator to use blank props as default
  - there's no nice easy way to add a default second arg I don't think
  - simpler to make it explicit
- deploy_stack.py to check for existence of names -stage suffix
  - is probably overkill if you have reduced use of resource_name to bare minimum and are also using random_name in many unimportant places
- don't include empty props ?
  - fails if u delete them
- only add bucket name if website ?
  - no it could be something u want a dashboard for
- rename deploy_stack.py config to avoid confusion with Config ?
  - no I prefer using config to dsl
- remove master outputs / list_outputs.py to iterate over all nested stacks
  - no because add_master() is quite elegant and it doesn't take much work to do this 
- move type filters into __init__.py ?
  - no because filters are different
- custom template type for dashboard ?
  - seems like overkill 
- aggregate IAM roles ?
  - doesn't seem worth it when unlikely to be template size constraint
- consider converting Template to extend object not dict ?
  - no point
- investigate template usage of lists of tuples (dicts ?)
  - no is fine
- refactor env.py so each function returns a template/templates ?
  - no is fine
- multiple sqs actions ?
  - i think leave it as single action for time being for simplicity
- add outputs support to fn::getatt ? option to bypass logical_id ?
  - think it's simpler just to have special function in master template
- refactor env to use Master function and don't have it attach directly ?
- preprocessor unit tests ?
  - probably not worth it at this stage, assuming it all compiles
- iam role pool to reduce template size ?
  - not going to reduce template size meaningfully
  - also feels like an over- optimisation
- don't put blank subs {} ?
  - doesn't work - needs blank
- preprocessor circularity detection ?
  - trig!=target unless s3 bucket, in which case paths can't be the same
  - just too meta for now
- separate functions for arn creators if they can't work on a single line
- eliminate `:::` in S3 bucket policy ?
  - no, seems to be standard case
  - https://docs.aws.amazon.com/AmazonS3/latest/dev/example-bucket-policies.html
- use ${AWS::Region} ?
  - no; dash will never support it as supposed to be multi- region
- convert underscored table attribute names to hashes ?
  - no; you don't do this for any other names so why bother with table ?
- find all tests rather than just index.py ?
  - conventions should be that all tests are in index.py
- remove managed policy support ?
  - no might be useful
- remove `-dashboard-` from dash name ?
  - too much hassle to allow dash to work without a name
- scripts to ping lambda, check logs ?
  - not really required as this is about deployment not runtime
  
### done

- pass rendered tree to template validation to avoid re- rendering
- check for superfluous parameters
- fn::sub local reference checks
- env validation failing
- master parameter types are incorrect
- join these non- output params and add them as master stack params
- filter param requirements not fulfilled by outputs on a per- template basis
- add these params as stack params (minus outputs prefix)
- add back env validation
- iterate over dash params
- modify dash rendering to use fn::sub
- separate params, outputs classes
- stop master being updated with globals
- replace cognito ${AWS::Region}
- runtime version parameter
- rename python-runtime as runtime
- refactor timer params as per layer params
- layer parameters
- components to add the parameters they require
- remove stage slug from template push keys
- check usage of resource_name in components
- fix queue name
- dashboard name refs are messed up
- bucket source arn is messed up
- cognito url refs are messed up
- examine outputted templates
- stack region
- apigw region ref
- apigw stage name ref
- remove staging dicts
- remove init_region
- remove stage from synth_templates args
- refactor stage as parameter
- refactor app as parameter
- refactor layer staging keys are parameters
- clean up lambda staging code
- refactor lambda staging key as parameter
- refactor bucket variable as parameter
- refactor runtime variable as parameter
- extended staging variables
- dedicated layer staging variable
- turn off component globals updating and see what breaks 
- change resource_name to use AppName, StageName variables (fn::sub)
- rename non_chart_value as resource_value
- move validation to end of synth process
- strip down deploy stack
- split deploy_stack into stack generation, stack deployment
- underscore app name where u underscore lambda name
- scripts/logs
- lambda logs script fails on lambda name check
- lambda ping failing on bad import
  - https://stackoverflow.com/questions/35340921/aws-lambda-import-module-error-in-python
  - https://forums.aws.amazon.com/thread.jspa?messageID=927865
- check stack deployment
- method updates still not being registered :(
  - https://console.aws.amazon.com/support/home#/case/?displayId=7282694321&language=en
- check stack generation
- add app to lambda staging
- refactor deploy_stack.py so single lambda deployable is passed around in `staging` variable
- commits to return dict rather than tuple
- check handler function exists
- check that handler for each action exists
- check that app code exists
- check if you need underscore any more
- unpack staging when passing around
- script to init staging
- pass staging instead of config["globals"]
- test lambdas push
- lambdas are missing paths
- push_lambdas.py to push a single deployable including root name
- no longer need to set classpath dynamically
- tests now broken with new package structure
- revert sample lambdas to use demo name
- allow single global commit to be specified
- see if lambda staging code can be cleaned up
- remove services
- remove lambda permissions
- remove filter_actions
